<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surd Snap | කරණි ගැළපීම</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala:wght@400;700&family=Roboto:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto', 'Noto Sans Sinhala', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #0f172a;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>
<body class="h-screen flex flex-col items-center justify-center">

    <!-- UI Overlay -->
    <div class="absolute top-0 w-full p-4 flex flex-col items-center pointer-events-none z-10">
        <h1 class="text-3xl md:text-4xl font-bold text-cyan-400 drop-shadow-md mb-2">Surd Snap</h1>
        <p class="text-lg md:text-xl text-yellow-200 bg-slate-800/80 px-4 py-2 rounded-full border border-yellow-500/30 shadow-lg">
            සරල කරපු Surd එක select කරන්න.
        </p>
        
        <div class="flex gap-12 mt-4">
            <div class="text-center">
                <p class="text-xs uppercase tracking-widest text-slate-400">Score</p>
                <p id="scoreEl" class="text-3xl font-bold text-green-400">0</p>
            </div>
            <div class="text-center">
                <p class="text-xs uppercase tracking-widest text-slate-400">Lives</p>
                <p id="livesEl" class="text-3xl font-bold text-red-400">♥♥♥</p>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 bg-slate-900 z-50 flex flex-col items-center justify-center p-4">
        <div class="bg-slate-800 p-8 rounded-2xl border border-slate-600 shadow-2xl max-w-lg w-full text-center">
            <h1 class="text-5xl font-bold text-cyan-400 mb-2">Surd Snap</h1>
            <h2 class="text-2xl font-bold text-white mb-6">කරණි ගැළපීම</h2>
            
            <div class="bg-slate-900/50 p-4 rounded-lg mb-8 text-left">
                <p class="text-gray-300 mb-2">Match the <strong>Entire Surd</strong> to its <strong>Simplest Form</strong>.</p>
                <div class="flex items-center justify-center gap-4 text-xl font-mono my-4">
                    <span class="px-4 py-2 bg-slate-700 rounded border border-slate-500">√12</span>
                    <span class="text-gray-500">➔</span>
                    <span class="px-4 py-2 bg-green-900/50 text-green-400 rounded border border-green-500">2√3</span>
                </div>
            </div>

            <button onclick="startGame()" class="w-full py-4 bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white font-bold rounded-xl text-2xl transition transform hover:scale-105 shadow-lg">
                Play Game (පටන් ගමු)
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 bg-slate-900/95 z-50 flex flex-col items-center justify-center p-4">
        <h2 class="text-6xl font-bold text-red-500 mb-2">Game Over!</h2>
        <p class="text-3xl text-white mb-8">Final Score: <span id="finalScore" class="text-yellow-400">0</span></p>
        <button onclick="startGame()" class="px-10 py-4 bg-yellow-500 hover:bg-yellow-400 text-slate-900 font-bold rounded-xl text-2xl transition transform hover:scale-105 shadow-lg">
            Try Again (නැවත කරන්න)
        </button>
    </div>

    <canvas id="gameCanvas" class="w-full h-full"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreEl');
        const livesEl = document.getElementById('livesEl');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');

        // Game State
        let score = 0;
        let lives = 3;
        let gameActive = false;
        let particles = [];
        let cards = [];
        let questionCard = null;
        let lastTime = 0;
        let level = 1;

        // Surd Data (Entire Surd -> Simplified Surd)
        const surdData = [
            { q: '√8', a: '2√2' },
            { q: '√12', a: '2√3' },
            { q: '√18', a: '3√2' },
            { q: '√20', a: '2√5' },
            { q: '√24', a: '2√6' },
            { q: '√27', a: '3√3' },
            { q: '√28', a: '2√7' },
            { q: '√32', a: '4√2' },
            { q: '√45', a: '3√5' },
            { q: '√48', a: '4√3' },
            { q: '√50', a: '5√2' },
            { q: '√54', a: '3√6' },
            { q: '√72', a: '6√2' },
            { q: '√75', a: '5√3' },
            { q: '√80', a: '4√5' },
            { q: '√98', a: '7√2' },
            { q: '√108', a: '6√3' },
            { q: '√125', a: '5√5' },
            { q: '√147', a: '7√3' },
            { q: '√200', a: '10√2' },
            { q: '√300', a: '10√3' }
        ];

        // Canvas Setup
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameActive) layoutCards();
        }
        window.addEventListener('resize', resize);

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * 5 + 2;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Card {
            constructor(text, isQuestion = false, isCorrect = false) {
                this.text = text;
                this.isQuestion = isQuestion;
                this.isCorrect = isCorrect; // Only relevant for option cards
                this.x = 0;
                this.y = 0;
                this.w = 0;
                this.h = 0;
                this.baseColor = isQuestion ? '#334155' : '#1e293b'; // slate-700 / slate-800
                this.hoverColor = isQuestion ? '#334155' : '#334155';
                this.borderColor = isQuestion ? '#38bdf8' : '#64748b'; // cyan-400 / slate-500
                this.isHovered = false;
                this.scale = 1;
                this.targetScale = 1;
                this.shake = 0;
            }

            draw() {
                // Apply shake
                let drawX = this.x + (Math.random() - 0.5) * this.shake;
                
                // Animate Scale
                this.scale += (this.targetScale - this.scale) * 0.2;
                
                const centerX = drawX + this.w / 2;
                const centerY = this.y + this.h / 2;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(this.scale, this.scale);
                ctx.translate(-centerX, -centerY);

                // Card Body
                ctx.fillStyle = this.isHovered && !this.isQuestion ? this.hoverColor : this.baseColor;
                ctx.beginPath();
                ctx.roundRect(drawX, this.y, this.w, this.h, 15);
                ctx.fill();

                // Border
                ctx.strokeStyle = this.borderColor;
                ctx.lineWidth = this.isQuestion ? 4 : 2;
                ctx.stroke();

                // Glow for question card
                if (this.isQuestion) {
                    ctx.shadowColor = '#38bdf8';
                    ctx.shadowBlur = 15;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Text
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${Math.min(this.h * 0.4, 40)}px Roboto`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, centerX, centerY);

                // Label for Question Card
                if (this.isQuestion) {
                    ctx.fillStyle = '#94a3b8';
                    ctx.font = '14px Roboto';
                    ctx.fillText("Entire Surd", centerX, this.y - 20);
                }

                ctx.restore();

                if (this.shake > 0) this.shake -= 1;
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function generateTurn() {
            // Pick a random surd
            const targetPair = surdData[Math.floor(Math.random() * surdData.length)];
            
            // Create Question Card
            questionCard = new Card(targetPair.q, true);

            // Create Option Cards
            cards = [];
            
            // Correct Answer
            cards.push(new Card(targetPair.a, false, true));

            // Distractors
            const distractors = [];
            while (distractors.length < 2) {
                const randomPair = surdData[Math.floor(Math.random() * surdData.length)];
                // Ensure unique answers and not the correct answer
                if (randomPair.a !== targetPair.a && !distractors.includes(randomPair.a)) {
                    distractors.push(randomPair.a);
                    cards.push(new Card(randomPair.a, false, false));
                }
            }

            // Shuffle Options
            cards.sort(() => Math.random() - 0.5);

            layoutCards();
        }

        function layoutCards() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Question Card Position (Top)
            const qWidth = Math.min(canvas.width * 0.4, 250);
            const qHeight = 120;
            if (questionCard) {
                questionCard.w = qWidth;
                questionCard.h = qHeight;
                questionCard.x = centerX - qWidth / 2;
                questionCard.y = canvas.height * 0.2;
            }

            // Option Cards Position (Bottom Row)
            const gap = 20;
            const optWidth = Math.min((canvas.width - (gap * 4)) / 3, 200);
            const optHeight = 100;
            const startX = (canvas.width - (cards.length * optWidth + (cards.length - 1) * gap)) / 2;
            const optY = canvas.height * 0.6;

            cards.forEach((card, index) => {
                card.w = optWidth;
                card.h = optHeight;
                card.x = startX + index * (optWidth + gap);
                card.y = optY;
            });
        }

        function startGame() {
            score = 0;
            lives = 3;
            gameActive = true;
            scoreEl.innerText = score;
            livesEl.innerText = '♥'.repeat(lives);
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            resize();
            generateTurn();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameActive = false;
            finalScoreEl.innerText = score;
            gameOverScreen.classList.remove('hidden');
        }

        function gameLoop(timestamp) {
            if (!gameActive) return;

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Question
            if (questionCard) questionCard.draw();

            // Draw Options
            cards.forEach(card => card.draw());

            // Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(i, 1);
            }

            requestAnimationFrame(gameLoop);
        }

        // Interaction Handling
        function handleInput(x, y) {
            if (!gameActive) return;

            // Check option cards
            for (let card of cards) {
                if (x > card.x && x < card.x + card.w &&
                    y > card.y && y < card.y + card.h) {
                    
                    if (card.isCorrect) {
                        // Correct Answer
                        score += 10;
                        scoreEl.innerText = score;
                        createExplosion(x, y, '#4ade80'); // Green
                        generateTurn();
                    } else {
                        // Wrong Answer
                        lives--;
                        livesEl.innerText = '♥'.repeat(lives);
                        createExplosion(x, y, '#f87171'); // Red
                        card.shake = 20; // Shake effect
                        card.borderColor = '#ef4444'; // Red border
                        setTimeout(() => {
                            if(gameActive) card.borderColor = '#64748b'; // Reset color
                        }, 500);
                        
                        if (lives <= 0) endGame();
                    }
                    return; // Only click one card
                }
            }
        }

        function handleHover(x, y) {
            let cursor = 'default';
            for (let card of cards) {
                if (x > card.x && x < card.x + card.w &&
                    y > card.y && y < card.y + card.h) {
                    card.isHovered = true;
                    card.targetScale = 1.05;
                    cursor = 'pointer';
                } else {
                    card.isHovered = false;
                    card.targetScale = 1.0;
                }
            }
            canvas.style.cursor = cursor;
        }

        // Event Listeners
        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            handleInput(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            handleHover(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleInput(touch.clientX - rect.left, touch.clientY - rect.top);
        }, { passive: false });

        // Initial Layout
        resize();

    </script>
</body>
</html>